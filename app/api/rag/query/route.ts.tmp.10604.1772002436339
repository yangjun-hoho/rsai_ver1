import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { searchSimilar } from '@/lib/rag/vectorCache';
import { ragDb } from '@/lib/rag/db';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

interface HistoryMessage {
  role: 'user' | 'assistant';
  content: string;
}

export async function POST(request: NextRequest) {
  try {
    const { categoryId, question, history = [] } = await request.json() as {
      categoryId: string;
      question: string;
      history: HistoryMessage[];
    };

    if (!categoryId || !question) {
      return NextResponse.json({ error: 'categoryId, question 필요' }, { status: 400 });
    }

    const category = RAG_CATEGORIES.find(c => c.id === categoryId);
    if (!category) return NextResponse.json({ error: '유효하지 않은 카테고리' }, { status: 400 });

    // 1. 질문 임베딩
    const embRes = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: question,
    });
    const queryEmbedding = embRes.data[0].embedding;

    // 2. 유사 청크 검색 (top-5)
    const topChunks = searchSimilar(categoryId, queryEmbedding, 5);

    if (topChunks.length === 0) {
      // 문서 없음 → 안내 메시지 SSE
      const encoder = new TextEncoder();
      const stream = new ReadableStream({
        start(controller) {
          const msg = '등록된 문서가 없습니다. 관리자 페이지에서 문서를 먼저 업로드해주세요.';
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'chunk', content: msg })}\n\n`));
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'done' })}\n\n`));
          controller.close();
        },
      });
      return new NextResponse(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache' } });
    }

    // 3. 컨텍스트 구성
    const context = topChunks
      .map((c, i) => `[${i + 1}] (출처: ${c.documentName})\n${c.chunkText}`)
      .join('\n\n');

    const sources = topChunks.map((c, i) => ({ index: i + 1, docName: c.documentName, chunk: c.chunkText }));

    // 4. 시스템 프롬프트
    const systemPrompt = `당신은 ${category.name} 전문 AI 상담사입니다.
아래 참고 문서를 바탕으로 사용자 질문에 정확히 답변하세요.

[참고 문서]
${context}

규칙:
1. 참고 문서에 없는 내용은 "등록된 문서에서 해당 내용을 찾을 수 없습니다"라고 답하세요.
2. 답변 시 근거 문서를 명시하세요 (예: "○○법 제○조에 따르면...").
3. 한국어로 답변하세요.`;

    // 5. SSE 스트리밍
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            stream: true,
            messages: [
              { role: 'system', content: systemPrompt },
              ...history.slice(-6), // 최근 6개 대화 이력
              { role: 'user', content: question },
            ],
          });

          for await (const chunk of completion) {
            const text = chunk.choices[0]?.delta?.content ?? '';
            if (text) {
              controller.enqueue(encoder.encode(
                `data: ${JSON.stringify({ type: 'chunk', content: text })}\n\n`
              ));
            }
          }

          // 출처 전송
          controller.enqueue(encoder.encode(
            `data: ${JSON.stringify({ type: 'sources', sources })}\n\n`
          ));
          controller.enqueue(encoder.encode(
            `data: ${JSON.stringify({ type: 'done' })}\n\n`
          ));
        } catch (err) {
          console.error('[rag/query stream]', err);
          controller.enqueue(encoder.encode(
            `data: ${JSON.stringify({ type: 'error', message: 'AI 응답 오류' })}\n\n`
          ));
        } finally {
          controller.close();
        }
      },
    });

    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error('[rag/query]', error);
    return NextResponse.json({ error: 'RAG 쿼리 실패' }, { status: 500 });
  }
}
